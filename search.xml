<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指 Offer II 017. 含有所有字符的最短字符串</title>
    <url>/my-first-article.html</url>
    <content><![CDATA[<p>我是短小精悍的文章摘要(๑•̀ㅂ•́) ✧</p>
<span id="more"></span>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定两个字符串 s 和t 。返回 s 中包含t的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。</p>
<p>如果 s 中存在多个符合条件的子字符串，返回任意一个。</p>
<p>注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot; </span><br><span class="line">解释：最短子字符串 &quot;BANC&quot; 包含了字符串 t 的所有字符 &#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure>


<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1=s.length(),len2=t.length();</span><br><span class="line">        <span class="keyword">if</span>(len1&lt;len2) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;  <span class="comment">// 滑动窗口中的双指针</span></span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> resl = <span class="number">0</span>,resr = <span class="number">0</span>; <span class="comment">// 用于记录最优解在s串的区间</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len2; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = t.charAt(i);</span><br><span class="line">            ++cnt[c];</span><br><span class="line">            <span class="comment">// k记录t串中不同字母的个数</span></span><br><span class="line">            <span class="keyword">if</span>(cnt[c]==<span class="number">1</span>) ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;len1) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            --cnt[c];</span><br><span class="line">            <span class="keyword">if</span>(cnt[c]==<span class="number">0</span>) --k;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * k==0，表明当前范围字符串符合情况，有待缩小范围。</span></span><br><span class="line"><span class="comment">                * While循环用于剔除当前解的左侧的冗余字符，</span></span><br><span class="line"><span class="comment">                * 也就是cnt[s.charAt(left)]&lt;0代表left所指字符为冗余。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">while</span>(cnt[s.charAt(left)]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                    ++cnt[s.charAt(left)]; <span class="comment">// 恢复，同步</span></span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(resr==resl || (resr-resl+<span class="number">1</span>)&gt;(right-left+<span class="number">1</span>)) &#123;</span><br><span class="line">                    resl=left;</span><br><span class="line">                    resr=right;</span><br><span class="line">                    <span class="comment">// 优化：如果当前解的长度和t串长度相同，直接返回。</span></span><br><span class="line">                    <span class="keyword">if</span>(resr-resl+<span class="number">1</span>==len2) <span class="keyword">return</span> s.substring(resl,resr+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找不到解时，resl=resr=0</span></span><br><span class="line">        <span class="keyword">return</span> resl==resr?<span class="string">&quot;&quot;</span>:s.substring(resl,resr+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
